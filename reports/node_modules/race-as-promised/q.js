async function safeRace(contenders) {
  const isPrimitive = (value) => {
    return (value === null)
      || ((typeof value !== 'object') && (typeof value !== 'function'));
  };

  // `Promise.race()` accepts an arbitrary iterable/generator; settle it into
  // a regular array, because we may have to iterate over it more than once.
  contenders = [...contenders];

  if (contenders.length === 0) {
    // `Promise.race()` on an empty argument is specified to return a promise
    // which never resolves.
    return new Promise(() => null);
  } else if (contenders.length === 1) {
    // Just one contender, so it can't possibly be a race. Note:
    // `Promise.race()` is specified to always return a pending promise, even
    // if the argument(s) are already settled, which is why we `await` instead
    // of `return` directly.
    return await contenders[0];
  }

  // Set up each contender that hasn't ever been encountered before. While
  // doing so, also short-circuit the race if we can determine a winner.
  // Specifically, `Promise.race()` specifies that the first (earliest in
  // `contenders`) already-settled contender wins, so if we observe N (N >= 0)
  // definitely-unsettled values followed by a definitely-settled one, then
  // the definitely-settled one is de facto the winner of the race.
  for (const contender of contenders) {
    if (isPrimitive(contender)) {
      // Short circuit: This contender is the definite winner of the race.
      // We `await` for the same reason as the `length === 1` case above.
      return await contender;
    } else {
      const record = wm.get(contender);
      switch (record?.settled) {
      case false: {
        // Nothing to do. It's known-unsettled.
        break;
      }
      case true: {
        // Short circuit: This contender is the definite winner of the
        // race. We `await` for the same reason as the `length === 1` case
        // above.
        return await contender;
      }
      case undefined: {
        // We've never encountered this contender before in any race. This
        // setup call happens once for the lifetime of the contender.
        const newRecord = this.#addRaceContender(contender);
        await null; // Ensure `settled === true` if `c` is already settled.
        if (newRecord.settled) {
          // Short circuit: This contender is the definite winner of the
          // race.
          return contender;
        }
      }
      }
    }
  }

  // All contenders are pending promises.

  let raceSettler;
  const result = new Promise((resolve, reject) => {
    raceSettler = { resolve, reject };
  });

  for (const contender of contenders) {
    const record = wm.get(contender);
    if (record.settled) {
      // Surprise! The contender got settled after it was checked during the
      // first pass. We can't just return here (well, ok, unless it happened
      // to be the first contender, but that's arguably more trouble than it's
      // worth to handle specially), because we may have polluted the
      // `raceMap` with our `raceSettler`. So, just resolve our `result`, and
      // let the `finally` below clean up the mess.
      raceSettler.resolve(contender);
      break;
    }
    record.races.add(raceSettler);
  }

  try {
    return await result;
  } finally {
    // Drop `raceSettler` (that is, the link to the `result` of the race
    // made by the call to this method) from any of the contenders that still
    // refer to it.
    for (const contender of contenders) {
      const record = wm.get(contender);
      record.races.delete(raceSettler);
    }
  }
}
